// Line following constants
#define SpeedSlow 10 // Speed of slower wheel in turn
#define SpeedFast 50 // Speed of faster wheel in turn
#define tolerance 40 // Value of the brightest spot on the line + some security margin (+5 is appropriate)
#define followSide false // True to follow right side of the line, false for left side
#define timeTillTurn 500 // Time not on line until making a full turn

// Wall following constants
#define distance 30 // Desired distance to wall while following it
#define SpeedSlowWall 10 // Speed of slower wheel in turn
#define SpeedFastWall 50 // Speed of faster wheel in turn
#define timeTillTurnWall 500 // Time not seen wall to decide it's the sharp turn
#define timeStraight 3500 // Time going straight after sharp turn
#define timeTurn 500 // Time to turn right after going straight
#define endTime 14000 // Time after sharp turn (beep sound) to the end

// General constants
#define waitPic 1000 // Time to show closed face before starting and exiting program
#define animInterval 250 // Speed of the animation

int iLight = 0;
int iDistance = 0;
long lLastSeen = 0;
bool bAnim = true;

// Subroutine for following the line
void followLine() {

     if (followSide) { // Depends on which side of the wall we're following
     
        if (iLight > tolerance) { // If not on the line go left
        
           OnFwd(OUT_A, SpeedFast);
           OnFwd(OUT_B, SpeedSlow);
           
        }
        else {
             OnFwd(OUT_B, SpeedFast); // If on the line go right
             OnFwd(OUT_A, SpeedSlow);
             lLastSeen = CurrentTick(); // Remember last time we've seen the line
        }
     }
     else {
          if (iLight > tolerance) { // If not on the line go right
          
             OnFwd(OUT_A, SpeedSlow);
             OnFwd(OUT_B, SpeedFast);
             
          }
          else {
               OnFwd(OUT_B, SpeedSlow); // If on the line go left
               OnFwd(OUT_A, SpeedFast);
               lLastSeen = CurrentTick(); // Remember last time we've seen the line
          }
     }
}

// Main line follower
void Liner() {

     // Initialize variables
     bool bWalled = false;
     lLastSeen = CurrentTick();

     // Executing as long as we haven't hit the wall
     while (!bWalled) {
     
           // Get current values
           iLight = Sensor(IN_2);
           iDistance = SensorUS(IN_4);

           if (iDistance < distance) { // Decide if we've hit the wall
              bWalled = true;
           }

           if (CurrentTick() - lLastSeen > timeTillTurn) { // If we haven't seen the line in a while,
                                                           // we've most likely run into a dead end
                                                           
              while (iLight > tolerance) { // Turn until we see the line again
              
                    if (followSide) { // When following right side, turn hard right
                       OnFwdSync(OUT_AB, 50, 100);
                    }
                    else { // When following left side, turn hard left
                         OnFwdSync(OUT_AB, 50, -100);
                    }
                    iLight = Sensor(IN_2); // Get current value
                    
              }
              
              Off(OUT_AB);
              lLastSeen = CurrentTick(); // Remember last time we've seen the line
           }
           else { // If we're not in a dead end, follow the line as usual
           
                followLine();
                
           }
     }
}

// Subrouting for following the wall
void followWall() {
     // Go left if too close to wall
     OnFwd(OUT_A, SpeedFastWall);
     OnFwd(OUT_B, SpeedSlowWall);
     until (SensorUS(IN_4) > distance || Sensor(IN_1) != 0);
     lLastSeen = CurrentTick(); // Remember last time we've seen the line

     // Go right if too far away from wall
     OnFwd(OUT_B, SpeedFastWall);
     OnFwd(OUT_A, SpeedSlowWall);
     until (SensorUS(IN_4) < distance || CurrentTick() - lLastSeen > timeTillTurnWall || Sensor(IN_1) != 0);
}

// Wall follower
void Waller() {

     // Initialize variables
     lLastSeen = CurrentTick();
     long timeToEnd = 2147483647; // Max value for a long, to make sure we don't exit prematurely
     
     while (Sensor(IN_1) == 0 && CurrentTick() - timeToEnd < endTime) { // Execute for as long as touch hasn't been activated
     
           // Go left if too close to wall
           OnFwd(OUT_A, SpeedFastWall);
           OnFwd(OUT_B, SpeedSlowWall);
           until (SensorUS(IN_4) > distance || Sensor(IN_1) != 0);
           OnFwdSync(OUT_AB, SpeedFastWall, 0);
           Wait(250);
           lLastSeen = CurrentTick(); // Remember last time we've seen the line
           
           followWall();
           
           if (CurrentTick() - lLastSeen > timeTillTurnWall) { // If we haven't seen the wall for a while,
                                                               // we've probably encountered a corner
              PlaySound(SOUND_DOUBLE_BEEP);
              timeToEnd = CurrentTick(); // Start counting the time
              
              // Go straight to get some distance and make sure we'll make it around the corner
              OnFwdSync(OUT_AB, SpeedFastWall, 0);
              Wait(timeStraight);
              
              // Turn for some time
              OnFwdSync(OUT_AB, SpeedFastWall, 50);
              Wait(timeTurn);
              
              // Go slightly right until we're at the wall again
              OnFwdSync(OUT_AB, SpeedFastWall, 10);
              until (SensorUS(IN_4) < distance || Sensor(IN_1) != 0);
              
              Off(OUT_AB);
           }
     }
}

// Animation task
task anim() {
     // Show open and closed face in short succession
     while (bAnim) {
           GraphicOut(28, LCD_LINE7, "faceopen.ric");
           Wait(animInterval);
           GraphicOut(28, LCD_LINE7, "faceclosed.ric");
           Wait(animInterval);
     }
}

// The main program
task controller() {

     // Start line following
     Liner();

     // When done, play sound and
     PlaySound(SOUND_DOUBLE_BEEP);

     // start wall following
     Waller();

     // When done, stop motors immediately and
     Off(OUT_AB);
     
     // stop the animation and display closed face
     bAnim = false;
     GraphicOut(28, LCD_LINE7, "faceclosed.ric");
     
     // Play end sound
     PlaySound(SOUND_LOW_BEEP);
     
     Wait(waitPic);

     StopAllTasks();
     
     // Done
     
}

// Main entry point to initialize sensors and start necessary tasks
task main() {

     // Make start sound and display closed face for a short time
     PlaySound(SOUND_UP);
     GraphicOut(28, LCD_LINE7, "faceclosed.ric");
     Wait(waitPic);
     
     // Initialize sensors
     SetSensorLight(IN_2);
     SetSensorLowspeed(IN_4);
     SetSensorTouch(IN_1);
     
     // Start animation and main program
     Precedes(anim, controller);
}
