// Line following constants
#define SpeedSlow 10
#define SpeedFast 50 // Depends on how narrow the curves are, the narrower, the quicker
#define tolerance 40 // Value of the brightest spot on the line + some security margin (+5 is feasible)
#define followSide false // True to follow right side of the line, false for left side
#define timeTillTurn 500 // Time not on line until making a full turn
// Wall following constants
#define distance 30 // Desired distance to wall while following it
#define SpeedSlowWall 10
#define SpeedFastWall 50

int iLight = 0;
int iDistance = 0;
long lLastSeen = 0;
bool bAnim = true;

// Subroutine for following the line
void followLine() {

     if (followSide) { // Depends on which side of the wall we're following
     
        if (iLight > tolerance) { // If not on the line go left
        
           OnFwd(OUT_A, SpeedFast);
           OnFwd(OUT_B, SpeedSlow);
           
        }
        else {
             OnFwd(OUT_B, SpeedFast); // If on the line go right
             OnFwd(OUT_A, SpeedSlow);
             lLastSeen = CurrentTick(); // Remember last time we've seen the line
        }
     }
     else {
          if (iLight > tolerance) { // If not on the line go right
          
             OnFwd(OUT_A, SpeedSlow);
             OnFwd(OUT_B, SpeedFast);
             
          }
          else {
               OnFwd(OUT_B, SpeedSlow); // If on the line go left
               OnFwd(OUT_A, SpeedFast);
               lLastSeen = CurrentTick(); // Remember last time we've seen the line
          }
     }
}

// Main line follower
void Liner() {

     // Initialize variables
     bool bWalled = false;
     lLastSeen = CurrentTick();

     // Executing as long as we haven't hit the wall
     while (!bWalled) {
     
           // Get current values
           iLight = Sensor(IN_2);
           iDistance = SensorUS(IN_4);

           if (iDistance < distance ) { // Decide if we've hit the wall
              bWalled = true;
           }

           if (CurrentTick() - lLastSeen > timeTillTurn) { // If we haven't seen the line in a while,
                                                           // we've most likely run into a dead end
              while (iLight > tolerance) {
              
                    if (followSide) { // When following right side, turn hard right
                       OnFwdSync(OUT_AB, 50, 100);
                    }
                    else { // When following left side, turn hard left
                         OnFwdSync(OUT_AB, 50, -100);
                    }
                    iLight = Sensor(IN_2); // Get current value
                    
              }
              
              Off(OUT_AB);
              lLastSeen = CurrentTick(); // Remember last time we've seen the line
           }
           else { // If we're not in a dead end, follow the line as usual
           
                followLine();
                
           }
     }
}

// Wall follower
void Waller() {

     // Initialize variables
     lLastSeen = CurrentTick();
     
     while (Sensor(IN_1) == 0) { // Execute if touch hasn't been activated
     
           // Go left if too close
           OnFwd(OUT_A, SpeedFastWall);
           OnFwd(OUT_B, SpeedSlowWall);
           until (SensorUS(IN_4) > distance || Sensor(IN_1) != 0);
           lLastSeen = CurrentTick(); // Remember last time we've seen the line
           
           // Go right if too far away
           OnFwd(OUT_B, SpeedFastWall);
           OnFwd(OUT_A, SpeedSlowWall);
           until (SensorUS(IN_4) < distance || CurrentTick() - lLastSeen > 500 || Sensor(IN_1) != 0);
           
           if (CurrentTick() - lLastSeen > 500) { // If we haven't seen the wall for a while,
                                                  // we've probably encountered a corner
              PlaySound(SOUND_DOUBLE_BEEP);
              
              // Go straight to get some distance and make sure we'll make it around the corner
              OnFwdSync(OUT_AB, SpeedFastWall, 0);
              Wait(2000);
              
              // Turn for some time
              OnFwdSync(OUT_AB, SpeedFastWall, 50);
              Wait(500);
              
              // Go slightly right until we're at the wall again
              OnFwdSync(OUT_AB, SpeedFastWall, 10);
              until (SensorUS(IN_4) < distance || Sensor(IN_1) != 0);
              
              Off(OUT_AB);
           }
     }
}

//
task anim() {
     // Show open and closed face in short succession
     while (bAnim) {
           GraphicOut(28, LCD_LINE7, "faceopen.ric");
           Wait(250);
           GraphicOut(28, LCD_LINE7, "faceclosed.ric");
           Wait(250);
     }
}

// The main program
task controller() {

     // Start line following
     Liner();

     // When done, play sound and
     PlaySound(SOUND_DOUBLE_BEEP);

     // Start wall following
     Waller();

     // When done, stop motors immediately and
     Off(OUT_AB);
     
     // stop the animation and display motionless face
     bAnim = false;
     GraphicOut(28, LCD_LINE7, "faceclosed.ric");
     
     // Play end sound
     PlaySound(SOUND_LOW_BEEP);
     
     Wait(1000);

     StopAllTasks();
     
     // Done
     
}

// Main entry point to initialize sensors and start necessary tasks
task main() {

     // Make start sound and display motionless face for a short time
     PlaySound(SOUND_UP);
     GraphicOut(28, LCD_LINE7, "faceclosed.ric");
     Wait(1000);
     
     // Initialize sensors
     SetSensorLight(IN_2);
     SetSensorLowspeed(IN_4);
     SetSensorTouch(IN_1);
     
     // Start animation and main program
     Precedes(anim, controller);
}
